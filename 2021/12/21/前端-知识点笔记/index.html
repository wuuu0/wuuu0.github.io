<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="学习资料前端面试题汇总 前端知识之HTML篇2021.12.15 - 2021.27    题号 补充    7 响应式图片之 srcset &amp; sizes 详讲   9 替换：红宝书 P841 小结 + 红宝书 P792 工作者线程类型简介一般来说，每个页面都对应一个浏览器渲染进程，该页面中的常规js脚本（script标签中的）会在渲染进程的主线程中执行。在常规js脚本的执行过程中，用户">
<meta property="og:type" content="article">
<meta property="og:title" content="前端-知识点笔记">
<meta property="og:url" content="http://example.com/2021/12/21/%E5%89%8D%E7%AB%AF-%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Wu&#39;s Blog">
<meta property="og:description" content="学习资料前端面试题汇总 前端知识之HTML篇2021.12.15 - 2021.27    题号 补充    7 响应式图片之 srcset &amp; sizes 详讲   9 替换：红宝书 P841 小结 + 红宝书 P792 工作者线程类型简介一般来说，每个页面都对应一个浏览器渲染进程，该页面中的常规js脚本（script标签中的）会在渲染进程的主线程中执行。在常规js脚本的执行过程中，用户">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/03/06/gmBXGE4aF3xY7jO.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/24/zVO4t9HI1RNQLDE.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/24/1Oy6bnwHjNg5Pfs.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/24/a8sZE3FdIitYU2o.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/24/tmIGKykpaBgEn2q.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/9ZCRy3UkN2x8hnA.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/27/2JQNZrinCwphuTf.png">
<meta property="og:image" content="https://s2.loli.net/2022/02/25/IYh5r12yGN8vUgB.jpg">
<meta property="og:image" content="https://s2.loli.net/2022/03/12/idsMCI8Vrnq5Lzl.png">
<meta property="og:image" content="https://s2.loli.net/2022/03/12/R6GyIPpe8VT25t9.png">
<meta property="og:image" content="https://s2.loli.net/2022/03/12/WjqXBYicKUbJT2v.png">
<meta property="og:image" content="https://segmentfault.com/img/bVbClUl">
<meta property="article:published_time" content="2021-12-21T07:03:34.000Z">
<meta property="article:modified_time" content="2022-03-12T05:50:18.307Z">
<meta property="article:author" content="Wu Chaojie">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/03/06/gmBXGE4aF3xY7jO.png">


<link rel="canonical" href="http://example.com/2021/12/21/%E5%89%8D%E7%AB%AF-%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2021/12/21/%E5%89%8D%E7%AB%AF-%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/","path":"2021/12/21/前端-知识点笔记/","title":"前端-知识点笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>前端-知识点笔记 | Wu's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Wu's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">CS Tech</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99"><span class="nav-number">1.</span> <span class="nav-text">学习资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87"><span class="nav-number">2.</span> <span class="nav-text">前端知识之HTML篇</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87"><span class="nav-number">3.</span> <span class="nav-text">前端知识之CSS篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-1-%E8%A1%A5%E5%85%85"><span class="nav-number">3.1.</span> <span class="nav-text">一.1 补充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-1-%E8%A1%A5%E5%85%85"><span class="nav-number">3.2.</span> <span class="nav-text">二.1 补充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-1"><span class="nav-number">3.3.</span> <span class="nav-text">三.1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-2"><span class="nav-number">3.4.</span> <span class="nav-text">三.2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-4"><span class="nav-number">3.5.</span> <span class="nav-text">三.4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B-1"><span class="nav-number">3.6.</span> <span class="nav-text">四.1</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%B9%8BJavaScript%E7%AF%87"><span class="nav-number">4.</span> <span class="nav-text">前端知识之JavaScript篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-16"><span class="nav-number">4.1.</span> <span class="nav-text">三.16</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-%E8%A1%A5%E5%85%85"><span class="nav-number">4.2.</span> <span class="nav-text">三.补充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94-1"><span class="nav-number">4.3.</span> <span class="nav-text">五.1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94-2-3"><span class="nav-number">4.4.</span> <span class="nav-text">五.2&#x2F;3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB-2"><span class="nav-number">4.5.</span> <span class="nav-text">八.2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87"><span class="nav-number">5.</span> <span class="nav-text">前端知识之浏览器原理篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94-1-%E6%9B%BF%E6%8D%A2"><span class="nav-number">5.1.</span> <span class="nav-text">五.1 替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83-3"><span class="nav-number">5.2.</span> <span class="nav-text">七.3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9ACookie-%E5%92%8C-Session-%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">5.3.</span> <span class="nav-text">补充：Cookie 和 Session 关系和区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%B9%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AF%87"><span class="nav-number">6.</span> <span class="nav-text">前端知识之性能优化篇</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%B9%8B%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%AF%87"><span class="nav-number">7.</span> <span class="nav-text">前端知识之前端工程化篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-1-git-%E5%92%8C-svn-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E6%9B%BF%E6%8D%A2%EF%BC%89"><span class="nav-number">7.1.</span> <span class="nav-text">一.1 git 和 svn 的区别（替换）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-1-webpack%E4%B8%8Egrunt%E3%80%81gulp%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%88%E6%9B%BF%E6%8D%A2%EF%BC%89"><span class="nav-number">7.2.</span> <span class="nav-text">二.1 webpack与grunt、gulp的不同（替换）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-13-%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%EF%BC%9F%E6%80%8E%E4%B9%88%E9%85%8D%E7%BD%AE%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%EF%BC%9F"><span class="nav-number">7.3.</span> <span class="nav-text">二.13 怎么配置单页面应用？怎么配置多页面应用？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%B9%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AF%87"><span class="nav-number">8.</span> <span class="nav-text">前端知识之计算机网络篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-4-%E8%A1%A5%E5%85%85"><span class="nav-number">8.1.</span> <span class="nav-text">一.4 补充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-9-%E6%9B%BF%E6%8D%A2"><span class="nav-number">8.2.</span> <span class="nav-text">一.9 替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-18-%E8%A1%A5%E5%85%85"><span class="nav-number">8.3.</span> <span class="nav-text">一.18 补充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-3-%E8%A1%A5%E5%85%85"><span class="nav-number">8.4.</span> <span class="nav-text">二.3 补充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-4-%E8%A1%A5%E5%85%85"><span class="nav-number">8.5.</span> <span class="nav-text">二.4 补充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-HTTP-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">8.6.</span> <span class="nav-text">三 HTTP 状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B-%E8%A1%A5%E5%85%85"><span class="nav-number">8.7.</span> <span class="nav-text">四.补充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94-%E6%9B%BF%E6%8D%A2"><span class="nav-number">8.8.</span> <span class="nav-text">五.替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD-%E8%A1%A5%E5%85%85"><span class="nav-number">8.9.</span> <span class="nav-text">六.补充</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83-%E8%A1%A5%E5%85%85"><span class="nav-number">8.10.</span> <span class="nav-text">七.补充</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81"><span class="nav-number">9.</span> <span class="nav-text">手写代码</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wu Chaojie"
      src="/images/miao.gif">
  <p class="site-author-name" itemprop="name">Wu Chaojie</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/wuuu0" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wuuu0" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/21/%E5%89%8D%E7%AB%AF-%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/miao.gif">
      <meta itemprop="name" content="Wu Chaojie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wu's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端-知识点笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-21 15:03:34" itemprop="dateCreated datePublished" datetime="2021-12-21T15:03:34+08:00">2021-12-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-03-12 13:50:18" itemprop="dateModified" datetime="2022-03-12T13:50:18+08:00">2022-03-12</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Front-end/" itemprop="url" rel="index"><span itemprop="name">Front-end</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p><a target="_blank" rel="noopener" href="https://www.yuque.com/cuggz/interview">前端面试题汇总</a></p>
<h2 id="前端知识之HTML篇"><a href="#前端知识之HTML篇" class="headerlink" title="前端知识之HTML篇"></a>前端知识之HTML篇</h2><p>2021.12.15 - 2021.27</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>补充</th>
</tr>
</thead>
<tbody><tr>
<td>7</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903922109267976">响应式图片之 srcset &amp; sizes 详讲</a></td>
</tr>
<tr>
<td>9</td>
<td>替换：红宝书 P841 小结 + 红宝书 P792 工作者线程类型简介<br>一般来说，每个页面都对应一个浏览器渲染进程，该页面中的常规js脚本（script标签中的）会在渲染进程的主线程中执行。在常规js脚本的执行过程中，用户界面是阻塞的。而<strong>工作者线程</strong>是在浏览器后台单独开设的进程或线程，它独立于渲染进程的主线程运行，不会阻塞用户界面。这非常适合复杂计算和数据处理，特别是需要花较长时间因而会影响用户使用网页的处理任务。工作者线程有自己独立的环境，只能通过异步消息与外界通信。</td>
</tr>
<tr>
<td>14</td>
<td>替代：label标签通常用作某个表单控件的说明：当用户选择……</td>
</tr>
</tbody></table>
<h2 id="前端知识之CSS篇"><a href="#前端知识之CSS篇" class="headerlink" title="前端知识之CSS篇"></a>前端知识之CSS篇</h2><p>2021.12.15 - 2021.1.27</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>补充内容</th>
</tr>
</thead>
<tbody><tr>
<td>一、1</td>
<td>补充：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/85788761">CSS–选择器及其优先级</a><br>讨论CSS优先级，首先是要符合选择器规则被选中，然后在能够选中该元素的选择器中做优先级的比较（这也是为什么兄弟后代等选择器的优先级为0）</td>
</tr>
<tr>
<td>一.3/4</td>
<td>补充：行内元素：padding 上下方向，会撑开border，但不会影响元素位置</td>
</tr>
<tr>
<td>一.9</td>
<td>替换：MDN的说法：<br>伪元素：选择元素的特定部分修改样式，或添加内容。<br>伪类：选择处于特定状态的元素，并修改其样式。</td>
</tr>
<tr>
<td>一.18</td>
<td><a target="_blank" rel="noopener" href="https://editor.leonh.space/2021/rediscover-pixel-dpi-ppi-and-pixel-density/#css-pixel">重新認識 Pixel、DPI / PPI 以及像素密度</a></td>
</tr>
<tr>
<td>一.20</td>
<td><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/59f31a1704de">css基线与行高</a></td>
</tr>
<tr>
<td>一.22</td>
<td>替换：<br>CSS预处理器用于将Sass、Less等语言编译成CSS，它允许我们使用层级、mixin、变量、循环、函数等语法，来编写样式代码。这样使我们的样式代码更加简洁易读，也更具有可维护性、可拓展性、和复用性。此外，使用Sass、Less可以轻松实现多重继承，且完全兼容CSS代码。<br>CSS后处理器在完成的CSS样式表中根据CSS规范处理CSS代码，以保证CSS代码的有效性。目前最常做的是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容的问题。</td>
</tr>
<tr>
<td>二.02</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903607347707918">前端响应式布局基础——rem</a></td>
</tr>
<tr>
<td>二.03</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">MDN-BFC</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25321647">10 分钟理解BFC 原理</a></td>
</tr>
<tr>
<td>二.07</td>
<td><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1N54y1i7dG?p=4">B站 CSS3-flex布局</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25303493">30分钟学会 flex 布局</a></td>
</tr>
<tr>
<td>二.11</td>
<td><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yugege/p/9264319.html">为什么height:100%不生效？</a><br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1575141/how-to-make-a-div-100-height-of-the-browser-window">How to make a div 100% height of the browser window</a><br>结论就是，使用百分比作为单位时，父级元素的 width 和 height 大小最好为确定值。在此题案例中，也就是最好给ul的容器div设置好宽高（比如 400x400）</td>
</tr>
<tr>
<td>三.2</td>
<td>关于css-clear属性的解释，看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear">MDN clear</a></td>
</tr>
<tr>
<td>三.3</td>
<td>依旧可以从两个方面来理解BFC的作用：触发BFC后对同级元素的影响（比如，两栏布局）；触发BFC后对BFC内部的元素的适应（比如撑开坍塌的高度）</td>
</tr>
<tr>
<td>四.1</td>
<td>设置一个像素为零的div块，可以想象以一个点划两条垂直和水平的线，border-top right bottom left 就是以这两条线为边界，border 的大小指定的是 border 的厚度</td>
</tr>
</tbody></table>
<h3 id="一-1-补充"><a href="#一-1-补充" class="headerlink" title="一.1 补充"></a>一.1 补充</h3><p>注意 类选择器 的同时类和后代的区别</p>
<div align="center">
    <img src="https://s2.loli.net/2022/03/06/gmBXGE4aF3xY7jO.png" width="70%">
</div>

<h3 id="二-1-补充"><a href="#二-1-补充" class="headerlink" title="二.1 补充"></a>二.1 补充</h3><p>百分比, em：具体的含义要看用在什么属性上：</p>
<table>
<thead>
<tr>
<th></th>
<th>line-height 以及 大部分属性</th>
<th>font-szie</th>
<th>盒子属性</th>
</tr>
</thead>
<tbody><tr>
<td>百分比</td>
<td>相比当前元素的字体大小</td>
<td>相比父级元素的字体大小</td>
<td>相比父级元素的盒子width</td>
</tr>
<tr>
<td>em</td>
<td>相比当前元素的字体大小</td>
<td>相比父级元素的字体大小</td>
<td>相比当前元素的字体大小</td>
</tr>
</tbody></table>
<h3 id="三-1"><a href="#三-1" class="headerlink" title="三.1"></a>三.1</h3><p>从两个方面理解浮动：浮动元素对同级元素的影响 + 浮动元素对父级（以及父级同级元素）的影响</p>
<ul>
<li>父级块元素，就当浮动元素不存在，无视浮动元素进行布局；但内容受影响。</li>
<li>父级行内元素，以及父级块元素中的行内元素，则会被浮动元素“排挤”。</li>
<li>同级块级元素，布局不受影响。但内容受影响</li>
<li>同级行内元素，会被浮动元素“排挤”。</li>
</ul>
<p>以下是浮动元素对其他元素的影响示例。创建了两个 div 块（为了看得更明显，规定这两个 div 的 height 为 150px，这也是后面测试 clearfix 失效的原因……），在第一个块中放入一些向左浮动的图片。</p>
<div align="center">
    <img src="https://s2.loli.net/2021/12/24/zVO4t9HI1RNQLDE.png" width="70%">
</div>

<blockquote>
<p>通过BFC、clearfix等方法撑起自适应的高度，事先不能设置好高度（当然，高度坍塌就是经常在没有设置高度的情况下发生的）。</p>
</blockquote>
<blockquote>
<p>补充一些好看的 CSS颜色（随手可用）：<a target="_blank" rel="noopener" href="https://www.wfublog.com/2015/08/css-color-code-table.html">CSS 色碼英文名稱對照表一覽</a>；salom, sandybrown, gold, lightgreen, skyblue, orchid</p>
</blockquote>
<h3 id="三-2"><a href="#三-2" class="headerlink" title="三.2"></a>三.2</h3><p>清除浮动用 after，即便最后的元素没有浮动，但只要同级元素中有浮动，它都能清除浮动。</p>
<p>清除浮动前</p>
<div align="center">
    <img src="https://s2.loli.net/2021/12/24/1Oy6bnwHjNg5Pfs.png" width="70%">
</div>

<p>清除浮动后。注意：最后的 div 和 span 都没有设置浮动属性。而且块元素中的内容溢出来的部分（绿色字，父级打错了，应该是同级），不会撑起来。——简单来说，就是布局时只考虑 元素-盒子模型 的大小，块元素的大小经过设置后与内容无关（布局不用管块的内容），而行内元素的大小与内容有关。</p>
<div align="center">
    <img src="https://s2.loli.net/2021/12/24/a8sZE3FdIitYU2o.png" width="70%">
</div>

<div align="center">
    <img src="https://s2.loli.net/2021/12/24/tmIGKykpaBgEn2q.png" width="70%">
</div>

<p>关于css-clear属性的解释，看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear">MDN clear</a>：<br>“clear CSS 属性指定一个元素是否必须移动(清除浮动后)到在它之前的浮动元素下面。”。重点在于“之前”，且应该指的是“所有的”浮动元素。</p>
<h3 id="三-4"><a href="#三-4" class="headerlink" title="三.4"></a>三.4</h3><p>对于同级元素，通过 hidden 触发 BFC 能够撑起高度，但是不能解决 margin 重叠问题。(将 outer1 和 outer2 调换顺序，即让底部块 hidden 触发 BFC 也不行)</p>
<div align="center">
    <img src="https://s2.loli.net/2021/12/26/9ZCRy3UkN2x8hnA.png" width="70%">
</div>

<p>一种情况是：想让兄弟元素的 margin 不重叠，就需要将一个兄弟放到一个 BFC 上下文中（而不是让它自己触发 BFC）。参考资料：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000012265930">边距重叠与BFC</a></p>
<p>其他情况是：将顶部/底部兄弟元素设置<code>display: inline-block</code>；将底部兄弟元素设置浮动、和绝对定位</p>
<p>关于父子元素的 margin 重叠问题 &amp; 子元素 margin 溢出父元素问题，参考 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039093635">子元素margin-top导致父元素移动的问题</a>。</p>
<h3 id="四-1"><a href="#四-1" class="headerlink" title="四.1"></a>四.1</h3><p>利用 border 来绘制各种图形——border的绘制规则</p>
<p>设置一个像素为零的div块，可以想象以一个点划两条垂直和水平的线，border-top right bottom left 就是以这两条线为边界，border 的大小指定的是 border 的厚度</p>
<div align="center">
    <img src="https://s2.loli.net/2021/12/27/2JQNZrinCwphuTf.png" width="30%">
</div>

<h2 id="前端知识之JavaScript篇"><a href="#前端知识之JavaScript篇" class="headerlink" title="前端知识之JavaScript篇"></a>前端知识之JavaScript篇</h2><p>2021.12.27 - 2022.1.8</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>补充内容</th>
</tr>
</thead>
<tbody><tr>
<td>一.11</td>
<td>红宝书 P71 + 各数据类型的转换规则 + 一.18 对象的转换规则<br>类型转换问题：操作（各种操作符）时，确定谁转换成谁，转换优先级和顺序 + a数据类型如何转化成b数据类型</td>
</tr>
<tr>
<td>一.21</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">MDN Object.assign()</a> 、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax#%E6%9E%84%E9%80%A0%E5%AD%97%E9%9D%A2%E9%87%8F%E5%AF%B9%E8%B1%A1%E6%97%B6%E4%BD%BF%E7%94%A8%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95">构造字面量对象时使用展开语法</a></td>
</tr>
<tr>
<td>二.2</td>
<td>面经说的有点绕。const 变量的值为引用值（也即对象数据类型）的时候，在栈空间的变量本身存储的值是对象的指针，它指向存储在堆内存中的真实对象的位置。此时变量直接存储的值，也就是栈空间中对象的指针不能修改，但是堆内存中的对象可以被修改。</td>
</tr>
<tr>
<td>二.6</td>
<td>扩展操作符的应用情况分类：两个方面：对什么数据操作 + 用于构造什么。<br>对普通对象使用：构造对象字面量<br>对数组对象使用：数组拷贝、数组合并、结构赋值拆分数组、用于函数调用时传入参数<br>ps: 对数组的扩展操作，逻辑上就等价于获得用逗号分隔的数据序列，比如 [1,2,3] —&gt; 1,2,3<br>对（非数组）可迭代对象使用：将可迭代对象转化成数组（比如 argument）<br>定义函数时在形参中使用：将参数收集到一个数组中，类似于 argument</td>
</tr>
<tr>
<td>三.5</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式 MDN</a></td>
</tr>
<tr>
<td>三.11</td>
<td>位运算简介看 红宝书：<br>位运算符用于数值的底层操作，也就是操作内存中表示数据的比特（位）。ES中的所有数值都是用IEEE754 64位格式存储，位操作并不直接应用到64位表示，而是先把值转换为32位整数再进行位操作，再把结果转换为64位。</td>
</tr>
<tr>
<td>三.17</td>
<td>关于提高性能：<br>在JS中，拿到一个函数要执行，会有以下步骤：<br>解析：预编译，语法检查，生成可执行代码（可能后续调用也会沿用已编译好的代码）；创建执行上下文，为声明的变量分配存储空间并让其占位（并不填充其被赋予的值）<BR>执行：执行函数中的代码<br>声明提升，就是为了方便声明的变量能够在一开始解析的时候就被一次性收集处理好，以提高性能</td>
</tr>
<tr>
<td>三.18</td>
<td>详见红宝书 P307</td>
</tr>
<tr>
<td>三.19</td>
<td>补充： <a target="_blank" rel="noopener" href="https://juejin.cn/post/6938581764432461854">聊聊什么是CommonJs和Es Module及它们的区别</a>、<a href=""></a><br>总结：<br>commonJs是被加载的时候运行，esModule是编译的时候运行（是否可以动态引入）<br>commonJs输出的是值的浅拷贝，esModule输出值的引用<br>commentJs具有缓存。在第一次被加载时，会完整运行整个文件并输出一个对象，拷贝（浅拷贝）在内存中。下次加载文件时，直接从内存中取值</td>
</tr>
<tr>
<td>三.20</td>
<td>补充：DOM-红宝书 P401</td>
</tr>
<tr>
<td>三.21</td>
<td>补充区别 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式的区别</a></td>
</tr>
<tr>
<td>三.23</td>
<td>面经说的不清楚 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EE411R7hL?p=1&share_medium=android&share_plat=android&share_session_id=1af835fa-014b-4365-b4cd-1b3c8970108a&share_source=WEIXIN&share_tag=s_i&timestamp=1641224087&unique_k=7oZrrz4">B站 什么是强/弱类型，动态/静态类型语言？</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BC%BA%E7%B1%BB%E5%9E%8B/5074514">百度百科 强类型语言</a></td>
</tr>
<tr>
<td>三.25</td>
<td>红宝书 for-in 用于枚举对象中的非符号键属性；for-of 用于遍历可迭代对象的元素</td>
</tr>
<tr>
<td>三.27</td>
<td>AJAX精简描述见笔记中的三.16；<br>补充：Axios是一个基于promise的HTTP库，可以用在浏览器和 node.js 中。它本质也是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本，符合最新的ES规范。</td>
</tr>
<tr>
<td>七.1</td>
<td>补充：发布订阅模式/事件机制 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/onepixel/p/10806891.html">观察者模式与订阅发布模式的区别</a></td>
</tr>
</tbody></table>
<p>获取数据的原型、构造函数（原始数据类型会被隐式转换成包装类型），然后再对比判断</p>
<ol>
<li><code>Object.prototype.getString.call(obj)</code> 返回字符串</li>
<li><code>obj._proto_</code> &lt;=&gt; <code>Object.getPrototypeOf(obj)</code> 返回原型对象</li>
<li><code>obj.constructor</code> 返回构造函数</li>
</ol>
<p>从类型入手，直接判断</p>
<ol>
<li><code>Array.isArray(obj)</code></li>
<li><code>Array.prototype.isPrototypeOf(obj)</code></li>
<li><code>obj instanceof Array</code></li>
</ol>
<h3 id="三-16"><a href="#三-16" class="headerlink" title="三.16"></a>三.16</h3><p>以红宝书 P711 为准</p>
<p>AJAX 是指通过 JavaScript 以异步通信的方式向服务器发送请求来获取额外的数据，而且可以局部地更新页面，不用刷新重新请求整个页面</p>
<p>大致步骤：</p>
<ul>
<li>创建XHR对象</li>
<li>注册onreadystatechange事件处理程序</li>
<li>调用open()方法为发送请求做准备</li>
<li>调用setRequestHeader()设置请求头部</li>
<li>调用send()方法发送请求</li>
<li>收到响应后XHR对象相应属性被填充响应数据</li>
</ul>
<p>代码示例见 P716</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SERVER_URL = <span class="string">&quot;/server&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="comment">// 设置状态监听函数</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 设置请求失败时的监听函数</span></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="built_in">this</span>.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建 Http 请求</span></span><br><span class="line">xhr.open(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 设置请求头信息</span></span><br><span class="line">xhr.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">xhr.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"><span class="comment">// 发送 Http 请求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>用 Promise 封装 AJAX</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJSON</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> getPromase = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status === <span class="number">304</span>) &#123;</span><br><span class="line">          resolve(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(xhr.status));</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.open(<span class="string">&quot;GET&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">    xhr.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    xhr.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> getPromase;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zoulonglong/article/details/80501029">form和ajax表单提交方式的区别</a></p>
<h3 id="三-补充"><a href="#三-补充" class="headerlink" title="三.补充"></a>三.补充</h3><p><a target="_blank" rel="noopener" href="https://github.com/zachrey/zblog/issues/3">【JS概念】纯函数和副作用</a><br><a target="_blank" rel="noopener" href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">函数式编程指北</a></p>
<p>红宝书 第7章 迭代器和生成器</p>
<h3 id="五-1"><a href="#五-1" class="headerlink" title="五.1"></a>五.1</h3><p>关于 <code>setTimeout()</code> ，它接受的函数只是函数的定义，并非直接调用了函数。函数中涉及到的外部的变量，得在调用它的时候才能确定变量的值。（也因此，外部函数/作用域执行结束后，其上下文不会被销毁——普通情况下执行完就要销毁，而会保留？）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于 for-let 语句，此前就有疑问，let 的作用域是块，那 for 语句括号中的 let 变量算什么？原来是，for 每执行一次块语句，就会为当前的块作用域 let 一个变量。普通情况下，此次块语句执行完成，这个块作用域的 let 变量也就被销毁了。但以下代码中，let 变量被引入到了 setTimeout 中的回调函数的定义中，只要每次的异步调用不完成，对应的 let 变量就不会被销毁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自行补充复习 红宝书 中闭包的内容。</p>
<h3 id="五-2-3"><a href="#五-2-3" class="headerlink" title="五.2/3"></a>五.2/3</h3><p>面试还是背红宝书 P87-89，面经保留“创建执行上下文”部分的内容</p>
<ul>
<li>执行上下文：是什么；变量对象</li>
<li>全局上下文：是什么；window对象；代码执行完后销毁；</li>
<li>函数上下文：是什么；活动对象；代码执行-函数上下文-执行栈；</li>
<li>作用域链：是什么-存储了各级变量对象；标识符解析规则</li>
</ul>
<p>关键在于理清概念：作用域&amp;访问规则、执行上下文、作用域链</p>
<h3 id="八-2"><a href="#八-2" class="headerlink" title="八.2"></a>八.2</h3><p>总结一下</p>
<table>
<thead>
<tr>
<th>继承方式</th>
<th>基本思路</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>原型链继承</td>
<td>new一个SuperType对象，<br>赋值给SubType的prototype属性</td>
<td></td>
<td>1.原型链中包含的引用值会被所有示例共享<br>2.子类实例化时不能给父类型的构造函数传参</td>
</tr>
<tr>
<td>盗用构造函数</td>
<td>在子类构造函数中通过call/apply<br>调用父类构造函数</td>
<td>1.解决了原型包含引用值导致的继承问题<br>2.可以在子类构造函数中向父类构造函数传参</td>
<td>1.必须在构造函数中定义方法，函数不能在实例间重用<br>2.子类不能访问父类原型上定义的方法</td>
</tr>
<tr>
<td>组合继承</td>
<td>综合了原型链和盗用构造函数：<br>用原型链继承原型上的属性和方法<br>用盗用构造函数继承实例属性</td>
<td>集中两者优点：<br>1.子类可以访问父类原型的属性和方法<br>2.每个实例都有自己的属性，且继承了父类实例属性</td>
<td>存在效率问题：父类构造函数会被调用两次</td>
</tr>
<tr>
<td>原型式继承</td>
<td>创建一个对象，<br>它由一个临时的构造函数创建，且_proto_属性指向某个对象</td>
<td>适合不需要单独创建构造函数，<br>但仍需要在对象间共享信息的场合</td>
<td>被“挂靠”的对象的引用值属性依旧会被“挂着”的对象共享</td>
</tr>
<tr>
<td>寄生式继承</td>
<td>类似于寄生构造函数/原型式继承和工厂模式：<br>创建一个函数，它用原型式继承创建一个实例，<br>然后再增强这个实例（添加属性、方法），最后返回它</td>
<td>适合关注对象，不在乎类型和构造函数的场景</td>
<td>对象的函数是独有的，不能重用</td>
</tr>
<tr>
<td>寄生式组合继承</td>
<td>用盗用构造函数继承属性，用混合式原型链继承方法：<br>也就是用寄生式继承获取一个增强的父类原型的“副本”，然后将它当作子类原型</td>
<td>改进了组合继承，效率更高</td>
<td></td>
</tr>
</tbody></table>
<div align="center">
    <img src="https://s2.loli.net/2022/02/25/IYh5r12yGN8vUgB.jpg" width="70%">
</div>

<h2 id="前端知识之浏览器原理篇"><a href="#前端知识之浏览器原理篇" class="headerlink" title="前端知识之浏览器原理篇"></a>前端知识之浏览器原理篇</h2><p>2022.1.8-2022.1.13</p>
<ul>
<li>重要补充资料——<strong>牢记</strong>：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1x54y1B7RE?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">【干货】浏览器是如何运作的？</a></li>
</ul>
<table>
<thead>
<tr>
<th>题号</th>
<th>补充内容</th>
</tr>
</thead>
<tbody><tr>
<td>一.1/2</td>
<td>补充：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903781704925191">XSS攻击与CSRF攻击</a><br>补充：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6912030758404259854">XSS攻击-攻击流程图</a><br>补充：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1s5411s7qd?from=search&seid=3968350037173219363&spm_id_from=333.337.0.0">B站 XSS原理和攻防 （讲的比较清晰）</a><br>补充：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mysticbinary/p/12542695.html">DOM-XSS攻击原理与防御</a> <br><strong>答题总结</strong>：<br>是什么、有什么危害、分类及其攻击流程-构造/用户访问/执行恶意代码/实现攻击效果<br>为什么、如何防范<br><br>DOM XSS：不经过服务器（使用本地已有/缓存的html、js等），且需要前端代码中本身存在一定的问题，然后攻击者根据这些问题针对性地构造出某种的恶意的输入（url、input等），让浏览器用有问题的参数运行js代码实现XSS攻击。</td>
</tr>
<tr>
<td>一.3/4</td>
<td>补充：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000024490213">CSRF攻击原理和防范措施</a></td>
</tr>
<tr>
<td>二.2</td>
<td>整理——什么是进程线程？：<br>从概念上来说，进程是某个程序的一次运行活动，线程是某个程序中的某个代码片段的一次运行活动。<br>详细的解释是，启动一个程序时，操作系统会为该程序创建一个独立的虚拟内存空间，在逻辑上这个虚拟的内存空间仅为这个程序所用，它用来存放程序代码、运行中的数据、打开的文件等等，然后CPU就会执行内存空间中的代码（每条代码/指令必有CPU活动，可能有I/O活动），我们将这一整个程序的运行过程称为进程。不同进程可以时分复用CPU，以实现并发的效果。<br>单个程序中不同的代码片段也可以时分复用地在cpu中并发执行，程序中的某个代码片段的运行活动，我们称之为线程，整个程序本身也可以看作是一个大的代码片段，它的运行活动我们称之为主线程。<br>总结来说，进程是资源分配的最小单位，线程是CPU调度的最小单位。通常将进程当作是某个程序运行时的资源容器（相互独立），线程则是该程序的各个代码片段的执行流（并发进行）。<br>ps：要从 底层真实情况+抽象后逻辑上的使用 两个角度来理解进程线程。在大多数情况下（特别是前端），我们以抽象逻辑视角来看待进程线程：每个进程都有自己的内存空间、多个CPU，占有了某些文件和打印机等I/O资源（一个沙盒环境，相互独立，并发进行，互不影响）；每个线程都有自己的CPU，按自己的执行流走就好。</td>
</tr>
<tr>
<td>五.2.4</td>
<td>区分：减少DOM操作，减少回流重绘（想想渲染流程，比如我可以在操作DOM时阻断后续的布局和绘制）</td>
</tr>
<tr>
<td>五.2.4</td>
<td>问题：documentFragment和渲染队列，做的事情很像，有何区别？它们最后将一波DOM操作一次性更新到DOM的操作，只触发一次重新渲染，但是本质上是否仍多次操作DOM？</td>
</tr>
<tr>
<td>七.1</td>
<td>补充：<a target="_blank" rel="noopener" href="https://catcat.cc/post/2020-06-23/">循序渐进理解：跨源跨域，再到 XSS 和 CSRF</a></td>
</tr>
<tr>
<td>七.2.1</td>
<td>替换：CORS的概念简介：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">MDN-CORS</a></td>
</tr>
<tr>
<td>八.9</td>
<td>补充：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54882306">浏览器与Node的事件循环(Event Loop)有何区别?</a></td>
</tr>
<tr>
<td>九.1</td>
<td>补充：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904016325902344">一文搞懂V8引擎的垃圾回收</a></td>
</tr>
</tbody></table>
<h3 id="五-1-替换"><a href="#五-1-替换" class="headerlink" title="五.1 替换"></a>五.1 替换</h3><div align="center">
    <img src="https://s2.loli.net/2022/03/12/idsMCI8Vrnq5Lzl.png" width="80%">
</div>

<ul>
<li>浏览器通过请求得到一个HTML文本</li>
<li>渲染进程解析HTML文本，构建DOM树</li>
<li>解析HTML的同时，如果遇到内联样式或者样式脚本，则下载并构建样式规则（stytle rules），若遇到JavaScript脚本，则会下载执行脚本。</li>
<li>DOM树和样式规则构建完成之后，渲染进程将两者合并成渲染树（render tree）</li>
<li>渲染进程开始对渲染树进行布局，生成布局树（layout tree）</li>
<li>渲染进程对布局树进行绘制，生成绘制记录</li>
<li>渲染进程的对布局树进行分层，分别栅格化每一层，并得到合成帧</li>
<li>渲染进程将合成帧信息发送给GPU进程显示到页面中</li>
</ul>
<h3 id="七-3"><a href="#七-3" class="headerlink" title="七.3"></a>七.3</h3><div align="center">
    <img src="https://s2.loli.net/2022/03/12/R6GyIPpe8VT25t9.png" width="80%">
</div>

<div align="center">
    <img src="https://s2.loli.net/2022/03/12/WjqXBYicKUbJT2v.png" width="80%">
</div>

<p>虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。</p>
<ul>
<li><p>正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。</p>
</li>
<li><p>正向代理一般是客户端架设的，比如在自己的机器上安装一个代理软件。而反向代理一般是服务器架设的，比如在自己的机器集群中部署一个反向代理服务器。</p>
</li>
<li><p>正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的就是真实的客户端。而在反向代理中，客户端不知道真正的服务器是谁，以为自己访问的就是真实的服务器。</p>
</li>
<li><p>正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。</p>
</li>
</ul>
<h3 id="补充：Cookie-和-Session-关系和区别"><a href="#补充：Cookie-和-Session-关系和区别" class="headerlink" title="补充：Cookie 和 Session 关系和区别"></a>补充：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903575684907016">Cookie 和 Session 关系和区别</a></h3><blockquote>
<p>链接：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/questionTerminal/5a2d287965824d3ca93921bf89f8654c">https://www.nowcoder.com/questionTerminal/5a2d287965824d3ca93921bf89f8654c</a></p>
</blockquote>
<p>cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户的状态，就使用response向客户端浏览器颁发一个cookie。客户端浏览器会把cookie保存起来。当浏览器再次请求该网站时，浏览器就会把请求地址和cookie一同给服务器。服务器检查该cookie，从而判断用户的身份和状态。服务器还可以根据需要修改cookie的内容。<br>session是另一种记录客户状态的机制。不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该session中查找该客户的状态就可以了。<br>如果说cookie机制是通过检查客户身上的“通行证”，那么session机制就是通过检查服务器上的“客户明细表”来确认客户身份。</p>
<h2 id="前端知识之性能优化篇"><a href="#前端知识之性能优化篇" class="headerlink" title="前端知识之性能优化篇"></a>前端知识之性能优化篇</h2><p>2022.1.21 - 2022. </p>
<table>
<thead>
<tr>
<th>题号</th>
<th>补充内容</th>
</tr>
</thead>
<tbody><tr>
<td>一</td>
<td><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV12T4y1P7Fh/?spm_id_from=333.788.recommend_more_video.0">用动画告诉你 CDN是什么</a></td>
</tr>
<tr>
<td>二.4</td>
<td>补充：要理解何为预和懒，首先要知道本来是如何加载。<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010032501">Web图片资源的加载与渲染时机</a> <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903545016156174">浏览器页面资源加载过程与优化</a></td>
</tr>
</tbody></table>
<h2 id="前端知识之前端工程化篇"><a href="#前端知识之前端工程化篇" class="headerlink" title="前端知识之前端工程化篇"></a>前端知识之前端工程化篇</h2><h3 id="一-1-git-和-svn-的区别（替换）"><a href="#一-1-git-和-svn-的区别（替换）" class="headerlink" title="一.1 git 和 svn 的区别（替换）"></a>一.1 git 和 svn 的区别（替换）</h3><p>完整对比：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/WindrunnerMax/p/14171924.html">Git与SVN对比</a></p>
<ul>
<li>git 和 svn 最大的区别在于 git 是分布式的而 svn 是集中式的<br>核心区别：版本库存储位置、个人版本管理方式、协作同步方式。<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248">集中式vs分布式</a>。</li>
<li>git 把内容按元数据方式存储，而SVN是按文件。<br>所有的资源控 制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。如果你把.git目录的体积大小跟.svn比较，你会发现它们差距很大。因 为,.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。</li>
<li>GIT分支和SVN的分支不同<br>svn 中的分支是复制了整个版本库的完整目录，而 git 的分支是将指针指向某次提交。因此 git 的分支创建更快，且开销更小。而且 svn 分支被所有成员共用，git 分支可以在本地创建被个人私用。<br>svn 会发生分支遗漏的情况。而 git 可以在同一个工作目录下的几个分支间快速切换，很容易发现并合并未被合并的分支。</li>
<li>git 没有一个全局的版本号，而 svn 有</li>
<li>GIT的内容完整性要优于SVN<br>GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</li>
</ul>
<h3 id="二-1-webpack与grunt、gulp的不同（替换）"><a href="#二-1-webpack与grunt、gulp的不同（替换）" class="headerlink" title="二.1 webpack与grunt、gulp的不同（替换）"></a>二.1 webpack与grunt、gulp的不同（替换）</h3><p>参考：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019650765">Webpack与Grunt、Gulp的区别？</a>、<a target="_blank" rel="noopener" href="http://www.noobyard.com/article/p-dsfelhmn-er.html">Webpack与Gulp、Grunt区别</a></p>
<ul>
<li>Grunt、Gulp是<strong>任务执行程序</strong>：它们在配置文件中，指明对某些文件进行相似 压缩、sass编译、单元测试、代码检查等反复重复的任务的具体步骤，以后能够自动替你完成这些任务。就像流⽔线，把资源放上去然后通过不同插件进⾏加⼯。</li>
<li>Webpack是<strong>模块打包程序</strong>：webpack 把项目当成一个总体，把⼀切当成模块。它从入口文件开始，递归地构建⼀个依赖关系图 ，其中包含应⽤程序需要的每个模块，然后将所有这些模块打包成⼀个或多个能直接被浏览器运行的 bundle。</li>
</ul>
<p>这两类程序的目标不一样。前者主要是解决重复任务的问题，后者则更像一套前端工程化解决方案，解决前端静态资源依赖管理的问题。严格来说，NPM 脚本才是 Grunt 和 Gulp 的替代品，但 webpack 确实客观上简化了此前“过度使用”Grunt和Gulp和NPM脚本的Web开发任务流程。</p>
<h3 id="二-13-怎么配置单页面应用？怎么配置多页面应用？"><a href="#二-13-怎么配置单页面应用？怎么配置多页面应用？" class="headerlink" title="二.13 怎么配置单页面应用？怎么配置多页面应用？"></a>二.13 怎么配置单页面应用？怎么配置多页面应用？</h3><p>待补充总结性内容</p>
<h2 id="前端知识之计算机网络篇"><a href="#前端知识之计算机网络篇" class="headerlink" title="前端知识之计算机网络篇"></a>前端知识之计算机网络篇</h2><h3 id="一-4-补充"><a href="#一-4-补充" class="headerlink" title="一.4 补充"></a>一.4 补充</h3><p>HTTP的常用方法</p>
<ul>
<li><p>GET方法<br>GET方法用于使用给定的URI从给定服务器中检索信息，即从指定资源中请求数据。使用GET方法的请求应该只是检索数据，并且不应对数据产生其他影响。</p>
</li>
<li><p>POST方法<br>POST方法用于将数据发送到服务器以创建或更新资源，它要求服务器确认请求中包含的内容作为由URI区分的Web资源的另一个下属。<br>POST请求永远不会被缓存，且对数据长度没有限制；我们无法从浏览器历史记录中查找到POST请求。</p>
</li>
<li><p>HEAD方法<br>HEAD方法与GET方法相同，但没有响应体，仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容。</p>
</li>
<li><p>PUT方法<br>PUT方法用于将数据发送到服务器以创建或更新资源，它可以用上传的内容替换目标资源中的所有当前内容。</p>
</li>
<li><p>DELETE方法<br>DELETE方法用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容。</p>
</li>
<li><p>CONNECT方法<br>CONNECT方法用来建立到给定URI标识的服务器的隧道；它通过简单的TCP / IP隧道更改请求连接，通常实使用解码的HTTP代理来进行SSL编码的通信（HTTPS）。</p>
</li>
<li><p>OPTIONS方法<br>OPTIONS方法用来描述了目标资源的通信选项，会返回服务器支持预定义URL的HTTP策略。</p>
</li>
<li><p>TRACE方法<br>TRACE方法用于沿着目标资源的路径执行消息环回测试；它回应收到的请求，以便客户可以看到中间服务器进行了哪些（假设任何）进度或增量。</p>
</li>
</ul>
<h3 id="一-9-替换"><a href="#一-9-替换" class="headerlink" title="一.9 替换"></a>一.9 替换</h3><ul>
<li>HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</li>
<li>使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</li>
<li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li>
<li>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</li>
<li>HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</li>
</ul>
<h3 id="一-18-补充"><a href="#一-18-补充" class="headerlink" title="一.18 补充"></a>一.18 补充</h3><p>HTTP1 —&gt; HTTP2 —&gt; HTTP3 发展脉络</p>
<p>HTTP1.0：一次HTTP请求应答，就是要建立一次TCP连接<br>HTTP1.1：多次HTTP请求应答，可以共用一次TCP连接，但是每对请求应答得排队一个个来——HTTP的队头阻塞<br>HTTP2.0：多次HTTP请求应答，可以共用一次TCP连接，以多路复用的形式实现多对请求应答同时进行，但传输层仍是TCP——TCP的队头阻塞<br>HTTP3.0：传输层改用UDP协议，配合QUIC协议簇实现了可靠传输，且没有TCP队头阻塞的问题</p>
<p>PS：注意区分 HTTP 和 TCP 的队头阻塞（head-of-line blocking）：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/330300133">关于队头阻塞（Head-of-Line blocking），看这一篇就足够了</a></p>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=GriONb4EfPY">HTTP/2 Critical Limitation that led to HTTP/3 &amp; QUIC</a></p>
<h3 id="二-3-补充"><a href="#二-3-补充" class="headerlink" title="二.3 补充"></a>二.3 补充</h3><p>假设A生成了一对公钥私钥：</p>
<p>非对称加密：A将公钥发送给B，B用A的公钥加密数据再发送给A，A用私钥解密——用来确保B发给A的内容不泄露<br>数字签名：A将公钥发送给B，A用私钥加密数据再将数据发送给B，B用A的公钥解密——用来确保数据是A发送的且未被篡改</p>
<p>核心都是：A的私钥不会通过网络传输，确保仅被A持有；A的公钥通过网络发送，谁都可能获取。</p>
<p>关键概念：服务器的公钥 –hash–&gt; 信息摘要 –CA私钥签名–&gt; 数字证书</p>
<p>数字证书的目标就是确保客户端收到的公钥是服务器的公钥。客户端根据数字证书（有CA签名确保其来源和正确性），可以获得服务器公钥的hash值，此为真；客户端还会收到“服务器”发过来的公钥（可能已被恶意置换），此为不确定，因此需要将其同样hash，与数字证书的hash来比较验伪。</p>
<p>本质就是要确定收到的“服务器”公钥是正确的，当然可以直接对服务器公钥做数字签名。但是HASH可以减少需要加密和传输的数据，且同样能证明公钥的正确性，就是多了一些步骤而已。</p>
<h3 id="二-4-补充"><a href="#二-4-补充" class="headerlink" title="二.4 补充"></a>二.4 补充</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021494676">HTTPS 详解一：附带最精美详尽的 HTTPS 原理图</a></p>
<p>HTTPS-TSL 四次握手</p>
<div align="center">
    <img src="https://segmentfault.com/img/bVbClUl" width=80%>
</div>

<h3 id="三-HTTP-状态码"><a href="#三-HTTP-状态码" class="headerlink" title="三 HTTP 状态码"></a>三 HTTP 状态码</h3><p><a target="_blank" rel="noopener" href="https://github.com/febobo/web-interview/issues/144">面试官：说说HTTP 常见的状态码有哪些，适用场景？</a></p>
<p>一些状态码的适用场景：</p>
<ul>
<li><p>100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输</p>
</li>
<li><p>206：一般用来做断点续传，或者是视频文件等大文件的加载</p>
</li>
<li><p>301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名</p>
</li>
<li><p>302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面</p>
</li>
<li><p>304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分</p>
</li>
<li><p>400：参数有误，请求无法被服务器识别</p>
</li>
<li><p>403：告诉客户端禁止访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回</p>
</li>
<li><p>404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时</p>
</li>
<li><p>503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503</p>
</li>
<li><p>504：网关超时</p>
</li>
</ul>
<h3 id="四-补充"><a href="#四-补充" class="headerlink" title="四.补充"></a>四.补充</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Rp4y1a7xQ?spm_id_from=333.1007.top_right_bar_window_history.content.click">详解DNS服务，DNS解析，DNS劫持和污染</a></p>
<p>DNS劫持：<strong>是</strong>指通过某些手段取得某域名的解析记录控制权，进而<strong>修改此域名的解析结果</strong>，导致对该域名的访问由原IP地址转入到修改后的指定IP。<strong>其结果</strong>就是对特定的网址不能访问或访问的是假网址，从而实现窃取资料或者破坏原有正常服务的目的。</p>
<h3 id="五-替换"><a href="#五-替换" class="headerlink" title="五.替换"></a>五.替换</h3><p><strong>理解</strong>计算机网络层次模型：</p>
<ul>
<li>每个层次的作用和联系：本为上层提供服务+使用下层服务/管理和优化下层+本身设计</li>
<li>同层次协议对等通信：可以单独讨论某个层次的协议</li>
<li>具体的实现：传输介质、硬件+软件、传输数据流&amp;各层次协议数据的包裹和解包</li>
</ul>
<p>在实际应用的时候，我们可以自上而下+一次仅看一层的来看。反正在某一层，我就能享受这一层的服务效果，且这个服务效果是基于下面层次的服务效果。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/69554474">【计算机网络】你真的理解数据链路层吗？</a></p>
<p><strong>网络模型</strong></p>
<p>（1）应用层：直接为应用进程提供网络通信服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。<br>（2）表示层：提供数据编码和转换功能，为不同终端的应用层提供数据和信息正确的语法表示变换方法。数据压缩和加密也是表示层可提供的转换功能之一。<br>（3）会话层：就是负责建立、管理和终止表示层实体之间的通信会话，实现两个会话用户之间实现有组织的，同步的数据传输。<br>（4）传输层：它负责为两台主机中的进程提供基础的通信服务。该层主要有以下两种协议：</p>
<ul>
<li>传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务。具体而言是建立主机端口之间连接实现可靠的数据传输。数据传输的基本单位是报文段（segment）。</li>
<li>用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。</li>
</ul>
<p>（5）网络层：它负责为两台主机提供通信服务。网络层把从传输层接收到的数据报文拆分成分组，通过路由选择算法选择合适的网络路径将数据分组传递到目标主机。<br>（6）数据链路层：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。数据链路层是对物理层传输原始比特流的功能的加强，将物理层提供的可能出错的物理连接改造成为逻辑上无差错的数据链路，使之对网络层表现为一无差错的线路。数据链路层提供了相邻节点间的线路，网络层则是规划了数据的传输路径。<br>（7）物理层：确保比特流数据在物理媒介上进行传输，定义了与传输媒介相关的接口特性，尽可能屏蔽传输介质和物理设备的差异。</p>
<h3 id="六-补充"><a href="#六-补充" class="headerlink" title="六.补充"></a>六.补充</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/NCXN2iW_DpEHEiePDP7Yhg">计算机网络经典20问！</a> 更精简</p>
<ul>
<li>TCP 设计动机</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kV411j7hA?spm_id_from=333.1007.top_right_bar_window_history.content.click">快速了解 TCP</a></p>
<p>总结来说：<strong>IP协议</strong> 只负责将零散的数据包从一个主机发送到另一个主机，不知道送给哪个应用程序，不知道哪些数据包属于哪些请求，不负责组装它们也不保证它们到达的先后顺序，非常的不可靠。<strong>TCP协议</strong> 则以“连接”的方式建立可靠的通信，实现了前面提到的IP协议做不到的事情，方便我们的应用程序间的请求和应答。但TCP协议也只是搭好了应用程序间通信的“管子”，其中的数据并无特殊的意义，只是实现了数据流的可靠流通而已，若想让这些数据带某些特定的意义，以及拆建“管子”的时机，就再上一层看 <strong>应用层协议</strong>。</p>
<ul>
<li>面经内容补充</li>
</ul>
<p>TCP协议 将应用层报文切割成报文段，再交给IP层，IP层进行包装即可（也就是分段的好的话就不需要IP层另外进行分片）；UDP协议 传输完整报文，不进行分段，交给IP层后由IP层来进行分片。</p>
<p>TCP协议内容：建立连接（三次握手）、传输过程（确认机制、超时重传/可靠传输、流量控制/ARQ协议和滑动窗口、拥塞控制）、断开连接（四次挥手）</p>
<p>替换：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039165592">TCP 三次握手和四次挥手</a></p>
<p>补充：快速重传、滑动窗口 的图文解释——<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/108822858">一文搞定 UDP 和 TCP 高频面试题！</a>、<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000022144695">面试准备 TCP 知识，看这一篇就够了</a></p>
<h3 id="七-补充"><a href="#七-补充" class="headerlink" title="七.补充"></a>七.补充</h3><p>注意区分：TCP是全双工（发送端连续发送数据的同时，接收端可以同时返回确认；也即可以连续多次发出数据，不必一一等待确认）、HTTP1.1是半双工（完成一对请求响应后，才能进行下一对）、HTTP2.0是全双工（可以同时发送多对请求响应，不必一一等待响应）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/welongfor/article/details/86622790">http 协议 是否 全双工 说明</a></p>
<p>但 WebSocket 和 HTTP 的区别，重点应该不在通信上的双工（即两边是否可以同时发送数据），而是<strong>行为逻辑</strong>。HTTP 必须先由客户端发起请求，然后由服务端响应。WebSocket 则可以由服务器主动向客户端推送信息。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1rt411P7G5?from=search&seid=379406896436056311&spm_id_from=333.337.0.0">保证前端实时性的技术：websocket</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=fG4dkrlaZAA">REST API (HTTP) vs Websockets - Concept Overview With Example</a></p>
<h2 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h2><p>关于<code>Promise.all()</code>的实现，在期约初始化程序中写的<code>p.then()</code>，也可以理解成一种“异步操作”（类似于setTimeout）</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/12/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/" rel="prev" title="数据结构与算法刷题">
                  <i class="fa fa-chevron-left"></i> 数据结构与算法刷题
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/01/30/React%E7%AC%94%E8%AE%B0/" rel="next" title="React笔记">
                  React笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wu Chaojie</span>
</div>
  <div class="powered-by">
  <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
    本站访客量:<span id="busuanzi_value_site_pv"></span>
  </span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
