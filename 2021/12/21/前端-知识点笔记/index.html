<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="学习资料前端面试题汇总 前端知识之HTML篇2021.12.15 - 2021.27 需要再补充一些面经 前端知识之CSS篇2021.12.15 - 2021.1.27    题号 补充内容    一.18 重新認識 Pixel、DPI &#x2F; PPI 以及像素密度   一.20 css基线与行高   二.02 前端响应式布局基础——rem   二.03 MDN-BFC10 分钟理解BFC 原理">
<meta property="og:type" content="article">
<meta property="og:title" content="前端-知识点笔记">
<meta property="og:url" content="http://example.com/2021/12/21/%E5%89%8D%E7%AB%AF-%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Wu&#39;s Blog">
<meta property="og:description" content="学习资料前端面试题汇总 前端知识之HTML篇2021.12.15 - 2021.27 需要再补充一些面经 前端知识之CSS篇2021.12.15 - 2021.1.27    题号 补充内容    一.18 重新認識 Pixel、DPI &#x2F; PPI 以及像素密度   一.20 css基线与行高   二.02 前端响应式布局基础——rem   二.03 MDN-BFC10 分钟理解BFC 原理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2021/12/24/zVO4t9HI1RNQLDE.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/24/1Oy6bnwHjNg5Pfs.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/24/a8sZE3FdIitYU2o.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/24/tmIGKykpaBgEn2q.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/26/9ZCRy3UkN2x8hnA.png">
<meta property="og:image" content="https://s2.loli.net/2021/12/27/2JQNZrinCwphuTf.png">
<meta property="og:image" content="https://s2.loli.net/2022/01/05/VgEHs45NtURnKJa.png">
<meta property="article:published_time" content="2021-12-21T07:03:34.000Z">
<meta property="article:modified_time" content="2022-01-13T06:49:06.306Z">
<meta property="article:author" content="Wu Chaojie">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2021/12/24/zVO4t9HI1RNQLDE.png">


<link rel="canonical" href="http://example.com/2021/12/21/%E5%89%8D%E7%AB%AF-%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2021/12/21/%E5%89%8D%E7%AB%AF-%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/","path":"2021/12/21/前端-知识点笔记/","title":"前端-知识点笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>前端-知识点笔记 | Wu's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Wu's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">CS Tech</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99"><span class="nav-number">1.</span> <span class="nav-text">学习资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%B9%8BHTML%E7%AF%87"><span class="nav-number">2.</span> <span class="nav-text">前端知识之HTML篇</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%B9%8BCSS%E7%AF%87"><span class="nav-number">3.</span> <span class="nav-text">前端知识之CSS篇</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%B9%8BJavaScript%E7%AF%87"><span class="nav-number">4.</span> <span class="nav-text">前端知识之JavaScript篇</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86%E7%AF%87"><span class="nav-number">5.</span> <span class="nav-text">前端知识之浏览器原理篇</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Wu Chaojie"
      src="/images/miao.gif">
  <p class="site-author-name" itemprop="name">Wu Chaojie</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/wuuu0" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;wuuu0" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/21/%E5%89%8D%E7%AB%AF-%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/miao.gif">
      <meta itemprop="name" content="Wu Chaojie">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wu's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          前端-知识点笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-21 15:03:34" itemprop="dateCreated datePublished" datetime="2021-12-21T15:03:34+08:00">2021-12-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-01-13 14:49:06" itemprop="dateModified" datetime="2022-01-13T14:49:06+08:00">2022-01-13</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Front-end/" itemprop="url" rel="index"><span itemprop="name">Front-end</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h2><p><a target="_blank" rel="noopener" href="https://www.yuque.com/cuggz/interview">前端面试题汇总</a></p>
<h2 id="前端知识之HTML篇"><a href="#前端知识之HTML篇" class="headerlink" title="前端知识之HTML篇"></a>前端知识之HTML篇</h2><p>2021.12.15 - 2021.27</p>
<p><mark>需要再补充一些面经</mark></p>
<h2 id="前端知识之CSS篇"><a href="#前端知识之CSS篇" class="headerlink" title="前端知识之CSS篇"></a>前端知识之CSS篇</h2><p>2021.12.15 - 2021.1.27</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>补充内容</th>
</tr>
</thead>
<tbody><tr>
<td>一.18</td>
<td><a target="_blank" rel="noopener" href="https://editor.leonh.space/2021/rediscover-pixel-dpi-ppi-and-pixel-density/#css-pixel">重新認識 Pixel、DPI / PPI 以及像素密度</a></td>
</tr>
<tr>
<td>一.20</td>
<td><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/59f31a1704de">css基线与行高</a></td>
</tr>
<tr>
<td>二.02</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903607347707918">前端响应式布局基础——rem</a></td>
</tr>
<tr>
<td>二.03</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context">MDN-BFC</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25321647">10 分钟理解BFC 原理</a></td>
</tr>
<tr>
<td>二.07</td>
<td><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1N54y1i7dG?p=4">B站 CSS3-flex布局</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25303493">30分钟学会 flex 布局</a></td>
</tr>
<tr>
<td>二.11</td>
<td><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yugege/p/9264319.html">为什么height:100%不生效？</a><br><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1575141/how-to-make-a-div-100-height-of-the-browser-window">How to make a div 100% height of the browser window</a><br>结论就是，使用百分比作为单位时，父级元素的 width 和 height 大小最好为确定值。在此题案例中，也就是最好给ul的容器div设置好宽高（比如 400x400）</td>
</tr>
<tr>
<td>三.2</td>
<td>关于css-clear属性的解释，看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear">MDN clear</a></td>
</tr>
<tr>
<td>三.3</td>
<td>依旧可以从两个方面来理解BFC的作用：触发BFC后对同级元素的影响（比如，两栏布局）；触发BFC后对BFC内部的元素的适应（比如撑开坍塌的高度）</td>
</tr>
<tr>
<td>四.1</td>
<td>设置一个像素为零的div块，可以想象以一个点划两条垂直和水平的线，border-top right bottom left 就是以这两条线为边界，border 的大小指定的是 border 的厚度</td>
</tr>
</tbody></table>
<p>三.1</p>
<p>从两个方面理解浮动：浮动元素对同级元素的影响 + 浮动元素对父级（以及父级同级元素）的影响</p>
<ul>
<li>父级块元素，就当浮动元素不存在，无视浮动元素进行布局；但内容受影响。</li>
<li>父级行内元素，以及父级块元素中的行内元素，则会被浮动元素“排挤”。</li>
<li>同级块级元素，布局不受影响。但内容受影响</li>
<li>同级行内元素，会被浮动元素“排挤”。</li>
</ul>
<p>以下是浮动元素对其他元素的影响示例。创建了两个 div 块（为了看得更明显，规定这两个 div 的 height 为 150px，这也是后面测试 clearfix 失效的原因……），在第一个块中放入一些向左浮动的图片。</p>
<div align="center">
    <img src="https://s2.loli.net/2021/12/24/zVO4t9HI1RNQLDE.png" width="70%">
</div>

<blockquote>
<p>通过BFC、clearfix等方法撑起自适应的高度，事先不能设置好高度（当然，高度坍塌就是经常在没有设置高度的情况下发生的）。</p>
</blockquote>
<blockquote>
<p>补充一些好看的 CSS颜色（随手可用）：<a target="_blank" rel="noopener" href="https://www.wfublog.com/2015/08/css-color-code-table.html">CSS 色碼英文名稱對照表一覽</a>；salom, sandybrown, gold, lightgreen, skyblue, orchid</p>
</blockquote>
<p>三.2</p>
<p>清除浮动用 after，即便最后的元素没有浮动，但只要同级元素中有浮动，它都能清除浮动。</p>
<p>清除浮动前</p>
<div align="center">
    <img src="https://s2.loli.net/2021/12/24/1Oy6bnwHjNg5Pfs.png" width="70%">
</div>

<p>清除浮动后。注意：最后的 div 和 span 都没有设置浮动属性。而且块元素中的内容溢出来的部分（绿色字，父级打错了，应该是同级），不会撑起来。——简单来说，就是布局时只考虑 元素-盒子模型 的大小，块元素的大小经过设置后与内容无关（布局不用管块的内容），而行内元素的大小与内容有关。</p>
<div align="center">
    <img src="https://s2.loli.net/2021/12/24/a8sZE3FdIitYU2o.png" width="70%">
</div>

<div align="center">
    <img src="https://s2.loli.net/2021/12/24/tmIGKykpaBgEn2q.png" width="70%">
</div>

<p>关于css-clear属性的解释，看 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/clear">MDN clear</a>：<br>“clear CSS 属性指定一个元素是否必须移动(清除浮动后)到在它之前的浮动元素下面。”。重点在于“之前”，且应该指的是“所有的”浮动元素。</p>
<p>三.4</p>
<p>对于同级元素，通过 hidden 触发 BFC 能够撑起高度，但是不能解决 margin 重叠问题。(将 outer1 和 outer2 调换顺序，即让底部块 hidden 触发 BFC 也不行)</p>
<div align="center">
    <img src="https://s2.loli.net/2021/12/26/9ZCRy3UkN2x8hnA.png" width="70%">
</div>

<p>关于父子元素的 margin 重叠问题 &amp; 子元素 margin 溢出父元素问题，参考 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039093635">子元素margin-top导致父元素移动的问题</a>。</p>
<p>四.1</p>
<p>利用 border 来绘制各种图形——border的绘制规则</p>
<p>设置一个像素为零的div块，可以想象以一个点划两条垂直和水平的线，border-top right bottom left 就是以这两条线为边界，border 的大小指定的是 border 的厚度</p>
<div align="center">
    <img src="https://s2.loli.net/2021/12/27/2JQNZrinCwphuTf.png" width="30%">
</div>

<p><mark>需要再补充一些面经</mark></p>
<h2 id="前端知识之JavaScript篇"><a href="#前端知识之JavaScript篇" class="headerlink" title="前端知识之JavaScript篇"></a>前端知识之JavaScript篇</h2><p>2021.12.27 - 2022.1.8</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>补充内容</th>
</tr>
</thead>
<tbody><tr>
<td>一.11</td>
<td>红宝书 P71 + 各数据类型的转换规则 + 一.18 对象的转换规则<br>类型转换问题：操作（各种操作符）时，确定谁转换成谁，转换优先级和顺序 + a数据类型如何转化成b数据类型</td>
</tr>
<tr>
<td>一.21</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">MDN Object.assign()</a> 、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax#%E6%9E%84%E9%80%A0%E5%AD%97%E9%9D%A2%E9%87%8F%E5%AF%B9%E8%B1%A1%E6%97%B6%E4%BD%BF%E7%94%A8%E5%B1%95%E5%BC%80%E8%AF%AD%E6%B3%95">构造字面量对象时使用展开语法</a></td>
</tr>
<tr>
<td>二.2</td>
<td>面经说的有点绕。const 变量的值为引用值（也即对象数据类型）的时候，在栈空间的变量本身存储的值是对象的指针，它指向存储在堆内存中的真实对象的位置。此时变量直接存储的值，也就是栈空间中对象的指针不能修改，但是堆内存中的对象可以被修改。</td>
</tr>
<tr>
<td>二.6</td>
<td>扩展操作符的应用情况分类：两个方面：对什么数据操作 + 用于构造什么。<br>对普通对象使用：构造对象字面量<br>对数组对象使用：数组拷贝、数组合并、结构赋值拆分数组、用于函数调用时传入参数<br>ps: 对数组的扩展操作，逻辑上就等价于获得用逗号分隔的数据序列，比如 [1,2,3] —&gt; 1,2,3<br>对（非数组）可迭代对象使用：将可迭代对象转化成数组（比如 argument）<br>定义函数时在形参中使用：将参数收集到一个数组中，类似于 argument</td>
</tr>
<tr>
<td>三.5</td>
<td><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式 MDN</a></td>
</tr>
<tr>
<td>三.11</td>
<td>位运算简介看 红宝书：<br>位运算符用于数值的底层操作，也就是操作内存中表示数据的比特（位）。ES中的所有数值都是用IEEE754 64位格式存储，位操作并不直接应用到64位表示，而是先把值转换为32位整数再进行位操作，再把结果转换为64位。</td>
</tr>
<tr>
<td>三.17</td>
<td>变量提升 提高性能：能够在解析和预编译阶段提高性能，它能够预先一次性地为变量分配栈空间，而不必在函数执行时临时多次分配</td>
</tr>
<tr>
<td>三.18</td>
<td>详见红宝书 P307</td>
</tr>
<tr>
<td>三.19</td>
<td>面经说的不清楚 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6938581764432461854">聊聊什么是CommonJs和Es Module及它们的区别</a></td>
</tr>
<tr>
<td>三.20</td>
<td>补充：DOM-红宝书 P401</td>
</tr>
<tr>
<td>三.21</td>
<td>补充区别 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式的区别</a></td>
</tr>
<tr>
<td>三.23</td>
<td>面经说的不清楚 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1EE411R7hL?p=1&share_medium=android&share_plat=android&share_session_id=1af835fa-014b-4365-b4cd-1b3c8970108a&share_source=WEIXIN&share_tag=s_i&timestamp=1641224087&unique_k=7oZrrz4">B站 什么是强/弱类型，动态/静态类型语言？</a>、<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BC%BA%E7%B1%BB%E5%9E%8B/5074514">百度百科 强类型语言</a></td>
</tr>
<tr>
<td>三.25</td>
<td>红宝书 for-in 用于枚举对象中的非符号键属性；for-of 用于遍历可迭代对象的元素</td>
</tr>
<tr>
<td>三.27</td>
<td>AJAX精简描述见笔记中的三.16；<br>补充：Axios是一个基于promise的HTTP库，可以用在浏览器和 node.js 中。它本质也是对原生XMLHttpRequest的封装，只不过它是Promise的实现版本，符合最新的ES规范。</td>
</tr>
</tbody></table>
<ul>
<li>三.16</li>
</ul>
<p>以红宝书 P711 为准</p>
<p>AJAX 是指通过 JavaScript 以异步通信的方式向服务器发送请求来获取额外的数据，而且可以局部地更新页面，不用重新请求和刷新整个页面。</p>
<p>大致步骤：创建XHR对象、注册onreadystatechange事件处理程序、调用open()方法为发送请求做准备、调用setRequestHeader()设置请求头部、调用send()方法发送请求、收到响应后XHR对象相应属性被填充响应数据</p>
<p>代码示例见 P716</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>) &#123;</span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">&quot;Request was unsuccessful: &quot;</span> + xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;postexample.php&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setResponseHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&quot;user-info);</span></span><br><span class="line"><span class="string">xhr.send(serialize(form));</span></span><br></pre></td></tr></table></figure>

<ul>
<li>四.1</li>
</ul>
<p>思考函数和对象的关系</p>
<p><strong>JS 函数</strong> 的本质是对象，而 <strong>对象</strong> 又需要用构造函数来创建，看似这是一个鸡生蛋蛋生鸡的矛盾问题，其实这是概念定义模糊的导致的。可以这样理解，<strong>函数</strong> 和 <strong>常规对象</strong>（常规意义的对象，键值对的集合，主要用于集成数据）确实不一样（将这两者作为根本起点，不然怎么都追溯不到源头），但是考虑到它们在存储本质上的相似性，还是将函数算作一种<strong>广义对象</strong>（此时对象主要突出其存储层面的意义）。</p>
<p>PS：函数和常规对象（定义完成后）的存储本质确实相同，都是在栈内存中有个变量存储指针，指针指向堆空间中的某个键值对集合的位置；但两者在使用调用的时候会有不同的行为（由解释器等决定，访问对象-获取它的属性，访问函数-获取它的属性，调用函数-执行各种语句）。我们可以将 <strong>函数</strong> 和 <strong>常规对象</strong> 这两个基本概念以及它们的底层本质 作为我们创建整个 JavaScript Object 体系的初始条件/原材料。</p>
<p>所以当我们追溯函数和常规对象的本质（存储形式如何，使用/调用时的行为），剥离“函数”和“对象”两个词汇对两者的概括和区分后，发现两者是各自存在的各自洽的，有区别也有共性。所以正确的表述是，<strong>JS 函数</strong> 的本质是<strong>广义对象</strong>， <strong>（常规&amp;广义）对象</strong> 需要用<strong>构造函数</strong>来创建。</p>
<div align="right">
    <img src="https://s2.loli.net/2022/01/05/VgEHs45NtURnKJa.png" width="80%">
</div>

<ul>
<li>五.1</li>
</ul>
<p>关于 <code>setTimeout()</code> ，它接受的函数只是函数的定义，并非直接调用了函数。函数中涉及到的外部的变量，得在调用它的时候才能确定变量的值。（也因此，外部函数/作用域执行结束后，其上下文不会被销毁——普通情况下执行完就要销毁，而会保留？）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于 for-let 语句，此前就有疑问，let 的作用域是块，那 for 语句括号中的 let 变量算什么？原来是，for 每执行一次块语句，就会为当前的块作用域 let 一个变量。普通情况下，此次块语句执行完成，这个块作用域的 let 变量也就被销毁了。但以下代码中，let 变量被引入到了 setTimeout 中的回调函数的定义中，只要每次的异步调用不完成，对应的 let 变量就不会被销毁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自行补充复习 红宝书 中闭包的内容。</p>
<p>五.2/3</p>
<p>面试还是背面经，但私下要有自己的理解</p>
<p>关键在于理清概念：作用域&amp;访问规则、执行上下文、作用域链</p>
<p>注：上下文变量对象 和 作用域链 的实际关系——见红宝书-闭包小节</p>
<p><strong>红宝书 小结</strong></p>
<blockquote>
<p>任何变量(不管包含的是原始值还是引用值)都存在于某个执行上下文中(也称为作用域)。这个上下文(作用域)决定了变量的生命周期，以及它们可以访问代码的哪些部分。执行上下文可以总结 如下。</p>
<ul>
<li>执行上下文分全局上下文、函数上下文和块级上下文。</li>
<li>代码执行流每进入一个新上下文，都会创建一个作用域链，用于搜索变量和函数。</li>
<li>函数或块的局部上下文不仅可以访问自己作用域内的变量，而且也可以访问任何包含上下文乃至全局上下文中的变量。</li>
<li>全局上下文只能访问全局上下文中的变量和函数，不能直接访问局部上下文中的任何数据。</li>
<li>变量的执行上下文用于确定什么时候释放内存。</li>
</ul>
</blockquote>
<p>注：一般来说，作用域偏向于描述一套我们编写代码是的访问数据的规则（作用域就是一片代码区域-全局/函数/块，规则就是当下区域代码能够访问当下区域和上层区域的数据），执行上下文则是这套规则的具体底层实现机制。小结中的<code>上下文</code>更偏向于是作用域的概念。</p>
<p><strong>补充：</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/482318118/answer/2085785870">JS 的执行上下文和作用域到底有什么区别和联系？</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bala/p/12146607.html">JS 代码的执行流程</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bala/p/12158354.html">JavaScript 是如何支持块级作用域的 —— 词法环境</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6896668614272024589">深入浅出执行上下文、词法环境、变量环境</a></p>
<p>梳理一下 执行上下文-变量存储-函数 的关系：</p>
<ol>
<li>以运行时环境的存储构造为基础——<a target="_blank" rel="noopener" href="https://www.cnblogs.com/bala/p/12188441.html">栈空间和堆空间：数据是如何存储的？</a>，进行后续思考。</li>
<li><strong>函数调用</strong>会创建执行上下文——它存储在栈结构中（包括入口程序的调用，对应全局上下文），上下文中包含一个变量对象/活动对象（完整的执行上下文见 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/bala/p/12188441.html">栈空间和堆空间：数据是如何存储的？</a>），存储了函数体中定义的变量（换句话说，不调用函数的话，函数体中定义的变量实际上在存储空间里是不存在的）。其中引用类型的数据（对象）会存储在堆空间中。</li>
<li><strong>函数</strong>仅<strong>定义</strong>未调用时，可以认为它是一个特殊的对象（也即引用类型数据）——该对象中包含它的源代码+属性，它的命名会当作变量存储在变量对象/活动对象中（但红宝书P311中，全局变量对象中的compare指向的是compare上下文，而不是compare定义，说明函数compare被调用后有一些特殊的操作）。</li>
</ol>
<ul>
<li>七.3</li>
</ul>
<p>关于 Promise，一是学习其行为：同步代码中的行为+异步部分的行为（代码语法，代码执行的流程），二是理解其逻辑作用：封装包裹异步操作，并作为其对应的“尚不存在的结果的替身”，让我们方便在同步代码中安排制定异步代码的内容和流程。</p>
<p>PS：在行为方面，期约有三种状态，并非都是pending状态——“尚不存在的结果”，我们自然可以创建一个有结果的期约来玩语法，但我们始终要清楚期约主要的作用和意义就是拿来处理“尚不存在的结果”。以下的思考，我们也都是要行为和逻辑结合起来思考，只单独考虑某一方面是无法充分理解期约的设计的。</p>
<p>单个期约的行为比较简单（三个状态，传入的执行器函数同步/立即执行），一串期约的链式作用的行为就有点复杂。关键在于理解<code>then()</code>。</p>
<p>在逻辑的角度/在同步代码中，可以这样理解<code>then()</code>：某个期约解决后，它接收这一个期约的结果，然后用一个处理函数进行一定的响应操作——可能会有返回值。<code>then()</code>会返回一个根据处理函数的返回值构建的期约。<br>从<code>then()</code>的行为方面考量，有意思的是它在同步代码中直接返回一个期约，这个期约和它的处理函数的返回值挂钩——也就是，then方法返回的期约，“接住”“兜住”了其处理函数返回的结果，这点挺神奇的。实际上来说，<code>then()</code>中的处理函数可能还未执行，其返回值也自然就还不存在，<code>then()</code>返回的期约是怎么和它挂钩呢？这就得看JS的底层实现了。<br>此处，我们可以从逻辑上将<code>then()</code>里面的处理函数，也当作是一个“异步操作”（类似于setTimeout及其回调。此处类比则是等待期约解决，回调就是处理函数），<code>then()</code> 返回的期约就是对它的封装，也是尚未执行的处理函数返回结果的替代。<br>进一步来说，以下面代码<code>p2</code>为例：同步代码执行时，<code>p2</code>就代表着尚未执行处理函数的返回值的替代。等到异步环节处理函数执行完，我们得到了一个返回的期约——也就是“等待之前的期约解决并执行处理函数”这个“异步操作”的结果，此时后台会自动调用<code>Promise.resovle()</code>将这个结果转化成<code>p2</code>的值，<code>p2</code>在这个角度上来说就不再是一个“替代”，而是货真价实的值。至于<code>p2</code>取得的这个处理函数返回的期约什么时候解决，又是另一回事了。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;<span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">1</span>)&#125;);</span><br><span class="line">p2 = p1.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;<span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">2</span>)&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">p3 = p2.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;<span class="built_in">setTimeout</span>(resolve, <span class="number">1000</span>, <span class="number">3</span>)&#125;);</span><br><span class="line">&#125;);</span><br><span class="line">p4 = p3.then(<span class="function">(<span class="params">value</span>)=&gt;</span>&#123;<span class="built_in">console</span>.log(value)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台每隔一秒输出</span></span><br><span class="line"><span class="number">1</span>                               VM4663:<span class="number">3</span> </span><br><span class="line"><span class="number">2</span>                               VM4663:<span class="number">7</span> </span><br><span class="line"><span class="number">3</span>                               VM4663:<span class="number">10</span> </span><br></pre></td></tr></table></figure>

<p><strong>总结来说</strong>：<br>一个期约就是一段包裹了异步操作的代码（对象），并代表了异步操作尚未存在的结果（要习惯期约的一体两面,它即代表了一定的操作，也代表该操作的结果）。</p>
<p><code>then()</code>就是等某个期约有结果后，针对它进行一定的操作（可能是同步操作或异步操作,异步操作一般被封装在一个期约中），这个操作可能有返回结果（确定的值，或者是一个异步操作的期约）。<code>then()</code>返回一个期约，这个期约可以理解为是对“等待之前的期约解决并执行处理函数”这个“异步操作”的封装，是对该操作尚未return的结果的替代。</p>
<p>进一步简化<code>then()</code>的细节，得出结论——将<strong>异步代码串行化</strong>：在同步代码中指定好一系列的<code>then()</code>后，在<u>异步阶段</u>中，最初定义的期约解决后，以此解决值为输入，执行其<code>then()</code>中的处理函数，处理函数返回的值用一个新的期约接住。新的期约结果解决后，再以此解决值为输入，继续执行后面的<code>then()</code>中的处理函数。（实际打代码的时候就这么看。重点在于：是一个接一个的，要等前一个解决；处理函数中要记得return需要的期约/异步操作）</p>
<ul>
<li>七.9</li>
</ul>
<p><code>then()</code>虽然避免了回调地狱，但是<code>then()</code>提供的操作异步代码的模式也有问题：往then里面塞处理函数比较麻烦，而且实际上同步代码只是给异步代码的执行做出了“规定”，同步代码和异步代码在概念上还是比较分离的（同步代码仅制定异步的规则——它自顾自地直接执行下去，一系列的then我们都得单独拉到“异步阶段”来思考——需要步步推演。但是如果只then一下的话，情况还是清晰明了的）</p>
<p>于是就有了 async 和 await，其巧妙的设计让我们能以写同步代码的方式写异步代码，是一种更自然方便的编程思维。</p>
<h2 id="前端知识之浏览器原理篇"><a href="#前端知识之浏览器原理篇" class="headerlink" title="前端知识之浏览器原理篇"></a>前端知识之浏览器原理篇</h2><p>2022.1.8-2022.1.13</p>
<p>重要补充资料：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1x54y1B7RE?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click">【干货】浏览器是如何运作的？</a></p>
<ul>
<li>关于函数的执行和执行上下文</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54882306">浏览器与Node的事件循环(Event Loop)有何区别?</a> 中先介绍了 JavaScript 在浏览器大背景下的执行机制。此处我补充思考一点，浏览器执行JS，是先编译出可执行代码，然后运行可执行代码的同时调用栈/执行栈会配合着运作（即运行到某个函数就将其上下文入栈，运行完毕即出栈）。此处有个疑问，当首屏渲染时，script 标签 代码全部运行完成后，进入监听事件等异步运行阶段，根据博客内容，main()函数（也即全局上下文？）已经出栈，但异步代码又是处理的 main() 中的内容，它们要如何追踪 main() 中的内容呢？闭包时的情况也有些许类似。</p>
<p>解答：<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bala/p/12188441.html">栈空间和堆空间：数据是如何存储的？</a> 中提到：“产生闭包的核心有两步：第一步是需要预扫描内部函数；第二部是把内部函数引用的外部变量保存到堆中。”<br>红宝书 P312 也在生命周期方面做出了解答（但并未说具体存储情况）。</p>
<table>
<thead>
<tr>
<th>题号</th>
<th>补充内容</th>
</tr>
</thead>
<tbody><tr>
<td>一.1</td>
<td>替换：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903781704925191">XSS攻击与CSRF攻击</a><br>补充：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6912030758404259854">XSS攻击-攻击流程图</a></td>
</tr>
<tr>
<td>一.2</td>
<td>整理——什么是进程线程？：<br>从概念上来说，进程是某个程序的一次运行活动，线程是某个程序中的某个代码片段的一次运行活动。<br>详细的解释是，启动一个程序时，操作系统会为该程序创建一个独立的虚拟内存空间，在逻辑上这个虚拟的内存空间仅为这个程序所用，它用来存放程序代码、运行中的数据、打开的文件等等，然后cpu就会执行内存空间中的代码，我们将这一整个程序的运行过程称为进程。不同进程可以时分复用cpu，以实现并发的效果。<br>单个程序中不同的代码片段也可以时分复用地在cpu中并发执行，程序中的某个代码片段的运行活动，我们称之为线程，整个程序本身也可以看作是一个大的代码片段，它的运行活动我们称之为主线程。<br>总结来说，进程是资源分配的最小单位，线程是CPU调度的最小单位。通常将进程当作是某个程序运行时的资源容器，线程则是该程序的各个代码片段的执行流。<br>ps：要从 底层真实情况+抽象后逻辑上的使用 两个角度来理解进程线程。在大多数情况下（特别是前端），我们以抽象逻辑视角来看待进程线程：每个进程都有自己的内存空间、多个cpu，但文件和打印机等I/O之类的资源还是得共享竞争；每个线程都有自己的cpu，按自己的执行流走就好</td>
</tr>
<tr>
<td>五.2.4</td>
<td>区分：减少DOM操作，减少回流重绘（想想渲染流程，比如我可以在操作DOM时阻断后续的布局和绘制）</td>
</tr>
<tr>
<td>七.2.1</td>
<td>替换：CORS的概念简介：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">MDN-CORS</a></td>
</tr>
<tr>
<td>八.9</td>
<td>补充：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/54882306">浏览器与Node的事件循环(Event Loop)有何区别?</a></td>
</tr>
<tr>
<td>九.1</td>
<td>补充：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904016325902344">一文搞懂V8引擎的垃圾回收</a></td>
</tr>
</tbody></table>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/12/20/%E5%89%8D%E7%AB%AF-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/" rel="prev" title="前端-数据结构与算法刷题">
                  <i class="fa fa-chevron-left"></i> 前端-数据结构与算法刷题
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wu Chaojie</span>
</div>
  <div class="powered-by">
  <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
    本站访客量:<span id="busuanzi_value_site_pv"></span>
  </span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  





</body>
</html>
